import { ethers } from "hardhat";
import chai from "chai";
import chaiAsPromised from "chai-as-promised";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { ContractReceipt, ContractTransaction, Event } from "@ethersproject/contracts";
import { Result } from "@ethersproject/abi";
import {
    ERC20SPV2,
    ERC20SPV2__factory,
    Permissions55,
    Permissions55__factory,
    SPVFactoryV2,
    SPVFactoryV2__factory,
} from "../typechain";
import { findEventArgsByNameFromReceipt } from "./lib/ethers-utils";

chai.use(chaiAsPromised);
const { expect } = chai;

const VALUES_SPV_NAME = "Unlimited Financial Services";
const VALUES_VENTURE_PARTNER = "Venture Partner";
const VALUES_DENOMINATION = "1000";

false &&
    describe("TokenFactory SPV2", () => {
        let token: ERC20SPV2,
            permissions: Permissions55,
            factory: SPVFactoryV2,
            deployer: SignerWithAddress,
            axel: SignerWithAddress,
            ben: SignerWithAddress,
            chantal: SignerWithAddress;

        beforeEach(async () => {
            [deployer, axel, ben, chantal] = await ethers.getSigners();

            /*console.log(`Deployer: ${deployer.address}`)
        console.log(`Axel: ${axel.address}`)
        console.log(`Ben: ${ben.address}`)
        console.log(`Chantal: ${chantal.address}`)*/

            const permissionsFactory = (await ethers.getContractFactory(
                "Permissions55",
                deployer
            )) as Permissions55__factory;
            permissions = await permissionsFactory.deploy("https://admin-token-uri");
            await permissions.deployed();

            const tokenFactoryFactory = (await ethers.getContractFactory(
                "SPVFactoryV2",
                deployer
            )) as SPVFactoryV2__factory;

            factory = await tokenFactoryFactory.deploy(permissions.address);

            await factory.deployed();

            expect(factory.address).to.properAddress;

            //console.log("OWNER: ", await factory.owner())
        });

        it("Chantal is not allowed to create token because of missing permissions", async () => {
            const useFactoryAsChantal = factory.connect(chantal);
            await expect(
                useFactoryAsChantal.create(
                    0,
                    "TokenForge",
                    "T20",
                    VALUES_SPV_NAME,
                    VALUES_VENTURE_PARTNER,
                    VALUES_DENOMINATION
                )
            ).to.be.revertedWith(`AccessControl: account ${chantal.address.toLowerCase()} is missing role 0x02`);
        });

        // 4
        describe("we can create Token per factory if we have the corresponding ROLE", async () => {
            const customPermissionSetId = 123;

            beforeEach(async () => {
                const tokenSPV2Factory = (await ethers.getContractFactory("ERC20SPV2", deployer)) as ERC20SPV2__factory;

                try {
                    const useFactoryAsChantal = factory.connect(chantal);

                    // Chantal receives DEPLOYER-Role
                    await permissions.create(chantal.address, await permissions.TOKEN_ROLE_DEPLOYER(), "https://");

                    const tokenTransaction: ContractTransaction = await useFactoryAsChantal.create(
                        customPermissionSetId,
                        "TokenForge",
                        "T20",
                        VALUES_SPV_NAME,
                        VALUES_VENTURE_PARTNER,
                        VALUES_DENOMINATION
                    );
                    const tokenAddress = await findEventArgsByNameFromReceipt(
                        await tokenTransaction.wait(),
                        "SpvIssued",
                        "result"
                    );

                    expect(tokenAddress).to.be.not.empty;

                    // use the created token as Token-Instance
                    token = tokenSPV2Factory.attach(tokenAddress);

                    const totalSupplyBefore = await token.totalSupply();
                    expect(totalSupplyBefore).to.eq(0);

                    const balanceBefore = await token.balanceOf(axel.address);
                    expect(balanceBefore).to.eq(0);
                } catch (e: unknown) {
                    console.log(e);
                }
            });

            it("will return the right property value", async () => {
                expect(await token.getProperty(await token.PROP_SPV_NAME())).to.eq(VALUES_SPV_NAME);
            });

            it("will return the correct owner", async () => {
                expect(await factory.owner()).to.eq(deployer.address);
            });

            it("will return the correct permissionSetId", async () => {
                expect(await token.getPermissionSetId()).to.eq(customPermissionSetId);
            });

            it("will return the correct token by index", async () => {
                expect(await factory.getTokenCount(deployer.address)).to.eq(0);
                await expect(factory.getToken(deployer.address, 0)).to.be.revertedWith(
                    "call revert exception; VM Exception while processing transaction: reverted with panic code 50"
                );
            });

            it("will return the correct token by index for chantal", async () => {
                expect(await factory.getTokenCount(chantal.address)).to.eq(1);
                expect(await factory.getToken(chantal.address, 0)).to.eq(token.address);
            });

            it("will add external token", async () => {
                await factory["addToken(address)"]("0xE6b4cfEa0cDaA586902Ffd9DDd538Dc7E1EB74Fa");

                expect(await factory.getToken(deployer.address, 0)).to.eq("0xE6b4cfEa0cDaA586902Ffd9DDd538Dc7E1EB74Fa");
            });

            it("will add external token for ben", async () => {
                await factory["addToken(address,address)"](ben.address, "0xE6b4cfEa0cDaA586902Ffd9DDd538Dc7E1EB74Fa");

                expect(await factory.getToken(ben.address, 0)).to.eq("0xE6b4cfEa0cDaA586902Ffd9DDd538Dc7E1EB74Fa");
            });

            it("Admin will be able to change the permissionSetId", async () => {
                const newPermissionSetId = customPermissionSetId + 222;
                await expect(token.setPermissionSetId(newPermissionSetId))
                    .to.emit(token, "PermissionSetIdChanged")
                    .withArgs(customPermissionSetId, newPermissionSetId);

                expect(await token.getPermissionSetId()).to.eq(newPermissionSetId);
            });

            it("Axel is not allowed to mint token yet, Ben and Chantal either", async () => {
                for (const signer of [axel, ben, chantal]) {
                    const tokenAsSigner = token.connect(signer);
                    await expect(tokenAsSigner.mint(axel.address, 1)).to.be.revertedWith(
                        `AccessControl: account ${signer.address.toLowerCase()} is missing role 0x05`
                    );
                }
            });

            it("Axel will receive the Minter Pass and thus is allowed to mint", async () => {
                await permissions.create(axel.address, await permissions.TOKEN_ROLE_MINTER(), "https://axel");
                expect(await permissions.balanceOf(axel.address, await permissions.TOKEN_ROLE_MINTER())).to.eq(1);

                await expect(token.connect(axel).mint(ben.address, 123))
                    // although minting is allowed, it will fail due to missing IS_WHITELISTED role for ben, this is expected behaviour
                    .to.be.revertedWith(`ERC20SPV2: account ${ben.address.toLowerCase()} is not verified`);
            });

            describe("Chantal becomes Minter", async () => {
                let chantalAsMinter: ERC20SPV2;

                beforeEach(async () => {
                    await permissions.create(chantal.address, await permissions.TOKEN_ROLE_MINTER(), "https://token");
                    chantalAsMinter = token.connect(chantal);
                });

                it("Axel will receive the Whitelisted Pass and thus is allowed to receive some tokens", async () => {
                    await permissions.create(
                        axel.address,
                        await permissions.TOKEN_ROLE_IS_WHITELISTED(),
                        "https://axel"
                    );
                    await expect(chantalAsMinter.mint(axel.address, 123))
                        .to.emit(token, "Transfer")
                        .withArgs(ethers.constants.AddressZero, axel.address, 123);
                });
            });
        });
    });
